/* $Id$ */

/*
 * This file is part of OpenTTD.
 * OpenTTD is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, version 2.
 * OpenTTD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with OpenTTD. If not, see <http://www.gnu.org/licenses/>.
 */

/** @file flowmapper.cpp Definition of flowmapper. */

#include "../stdafx.h"
#include "flowmapper.h"

/**
 * Map the paths generated by the MCF solver into flows associated with nodes.
 * @param component the link graph component to be used.
 */
void FlowMapper::Run(LinkGraphJob *job)
{
	LinkGraph *graph = &job->Graph();
	/* Time the graph has been running without being compressed. */
	uint runtime = job->JoinDate() - job->Settings().recalc_time - graph->GetLastCompression();

	for (NodeID node_id = 0; node_id < graph->GetSize(); ++node_id) {
		Node &prev_node = graph->GetNode(node_id);
		NodeAnnotation &prev_anno = job->GetNode(node_id);
		StationID prev = prev_node.station;
		PathSet &paths = prev_anno.paths;
		for (PathSet::iterator i = paths.begin(); i != paths.end(); ++i) {
			Path *path = *i;
			uint flow = path->GetFlow();
			if (flow == 0) continue;
			/* compress to monthly value */
			flow = max(1U, flow * 30 / runtime);
			NodeAnnotation &node = job->GetNode(path->GetNode());
			StationID via = graph->GetNode(path->GetNode()).station;
			assert(prev != via);
			StationID origin = graph->GetNode(path->GetOrigin()).station;
			assert(via != origin);
			FlowStatMap::iterator origin_it = node.flows.find(origin);
			/* Mark all of the flow for local consumption at "first". */
			if (origin_it == node.flows.end()) {
				node.flows.insert(std::make_pair(origin, FlowStat(via, flow)));
			} else {
				origin_it->second.ChangeShare(via, flow);
				/* Find simple circular flows ... */
				assert(origin_it->second.GetShare(prev) == 0);
			}
			/* Pass some of the flow marked for local consumption at "prev" on
			 * to this node. */
			FlowStatMap::iterator prev_it = prev_anno.flows.find(origin);
			if (prev_it == prev_anno.flows.end()) {
				FlowStat fs(via, flow);
				if (prev != origin) fs.AppendShare(INVALID_STATION, flow);
				prev_anno.flows.insert(std::make_pair(origin, fs));
			} else {
				prev_it->second.ChangeShare(via, flow);
				if (prev != origin) prev_it->second.ChangeShare(INVALID_STATION, flow);
			}
		}
	}

	for (NodeID node_id = 0; node_id < graph->GetSize(); ++node_id) {
		/* Remove local consumption shares marked as invalid. */
		FlowStatMap & flows = job->GetNode(node_id).flows;
		for (FlowStatMap::iterator i = flows.begin(); i != flows.end(); ++i) {
			FlowStat &fs = i->second;
			uint local = fs.GetShare(INVALID_STATION);
			fs.ChangeShare(graph->GetNode(node_id).station, -local);
			fs.ChangeShare(INVALID_STATION, -local);
		}
		/* Clear paths. */
		PathSet &paths = job->GetNode(node_id).paths;
		for (PathSet::iterator i = paths.begin(); i != paths.end(); ++i) {
			delete *i;
		}
		paths.clear();
	}
}
